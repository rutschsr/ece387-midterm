   1               		.file	"USART.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	initUSART
  12               	initUSART:
  13               	.LFB0:
  14               		.file 1 "USART.c"
   1:USART.c       **** /*
   2:USART.c       ****   Quick and dirty functions that make serial communications work.
   3:USART.c       ****   Note that receiveByte() blocks -- it sits and waits _forever_ for
   4:USART.c       ****    a byte to come in.  If you're doing anything that's more interesting,
   5:USART.c       ****    you'll want to implement this with interrupts.
   6:USART.c       ****    initUSART requires BAUDRATE to be defined in order to calculate
   7:USART.c       ****      the bit-rate multiplier.  9600 is a reasonable default.
   8:USART.c       ****   May not work with some of the older chips:
   9:USART.c       ****     Tiny2313, Mega8, Mega16, Mega32 have different pin macros
  10:USART.c       ****     If you're using these chips, see (e.g.) iom8.h for how it's done.
  11:USART.c       ****     These old chips don't specify UDR0 vs UDR1.
  12:USART.c       ****     Correspondingly, the macros will just be defined as UDR.
  13:USART.c       **** */
  14:USART.c       **** 
  15:USART.c       **** #include <avr/io.h>
  16:USART.c       **** #include "USART.h"
  17:USART.c       **** #include <util/setbaud.h>
  18:USART.c       **** 
  19:USART.c       **** void initUSART(void) {                                /* requires BAUD */
  15               		.loc 1 19 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  20:USART.c       ****   UBRR0H = UBRRH_VALUE;                        /* defined in setbaud.h */
  21               		.loc 1 20 0
  22 0000 1092 C500 		sts 197,__zero_reg__
  21:USART.c       ****   UBRR0L = UBRRL_VALUE;
  23               		.loc 1 21 0
  24 0004 87E6      		ldi r24,lo8(103)
  25 0006 8093 C400 		sts 196,r24
  22:USART.c       **** #if USE_2X
  23:USART.c       ****   UCSR0A |= (1 << U2X0);
  24:USART.c       **** #else
  25:USART.c       ****   UCSR0A &= ~(1 << U2X0);
  26               		.loc 1 25 0
  27 000a E0EC      		ldi r30,lo8(-64)
  28 000c F0E0      		ldi r31,0
  29 000e 8081      		ld r24,Z
  30 0010 8D7F      		andi r24,lo8(-3)
  31 0012 8083      		st Z,r24
  26:USART.c       **** #endif
  27:USART.c       ****                                   /* Enable USART transmitter/receiver */
  28:USART.c       ****   UCSR0B = (1 << TXEN0) | (1 << RXEN0);
  32               		.loc 1 28 0
  33 0014 88E1      		ldi r24,lo8(24)
  34 0016 8093 C100 		sts 193,r24
  29:USART.c       ****   UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);   /* 8 data bits, 1 stop bit */
  35               		.loc 1 29 0
  36 001a 86E0      		ldi r24,lo8(6)
  37 001c 8093 C200 		sts 194,r24
  38 0020 0895      		ret
  39               		.cfi_endproc
  40               	.LFE0:
  42               	.global	transmitByte
  44               	transmitByte:
  45               	.LFB1:
  30:USART.c       **** }
  31:USART.c       **** 
  32:USART.c       **** 
  33:USART.c       **** void transmitByte(uint8_t data) {
  46               		.loc 1 33 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  52               	.LVL0:
  53               	.L3:
  34:USART.c       ****                                      /* Wait for empty transmit buffer */
  35:USART.c       ****   loop_until_bit_is_set(UCSR0A, UDRE0);
  54               		.loc 1 35 0 discriminator 1
  55 0022 9091 C000 		lds r25,192
  56               		.loc 1 35 0 discriminator 1
  57 0026 95FF      		sbrs r25,5
  58 0028 00C0      		rjmp .L3
  36:USART.c       ****   UDR0 = data;                                            /* send data */
  59               		.loc 1 36 0
  60 002a 8093 C600 		sts 198,r24
  61 002e 0895      		ret
  62               		.cfi_endproc
  63               	.LFE1:
  65               	.global	receiveByte
  67               	receiveByte:
  68               	.LFB2:
  37:USART.c       **** }
  38:USART.c       **** 
  39:USART.c       **** uint8_t receiveByte(void) {
  69               		.loc 1 39 0
  70               		.cfi_startproc
  71               	/* prologue: function */
  72               	/* frame size = 0 */
  73               	/* stack size = 0 */
  74               	.L__stack_usage = 0
  75               	.L8:
  40:USART.c       ****   loop_until_bit_is_set(UCSR0A, RXC0);       /* Wait for incoming data */
  76               		.loc 1 40 0 discriminator 1
  77 0030 8091 C000 		lds r24,192
  78               		.loc 1 40 0 discriminator 1
  79 0034 87FF      		sbrs r24,7
  80 0036 00C0      		rjmp .L8
  41:USART.c       ****   return UDR0;                                /* return register value */
  81               		.loc 1 41 0
  82 0038 8091 C600 		lds r24,198
  42:USART.c       **** }
  83               		.loc 1 42 0
  84 003c 0895      		ret
  85               		.cfi_endproc
  86               	.LFE2:
  88               	.global	printString
  90               	printString:
  91               	.LFB3:
  43:USART.c       **** 
  44:USART.c       **** 
  45:USART.c       ****                        /* Here are a bunch of useful printing commands */
  46:USART.c       **** 
  47:USART.c       **** void printString(const char myString[]) {
  92               		.loc 1 47 0
  93               		.cfi_startproc
  94               	.LVL1:
  95 003e 0F93      		push r16
  96               	.LCFI0:
  97               		.cfi_def_cfa_offset 3
  98               		.cfi_offset 16, -2
  99 0040 1F93      		push r17
 100               	.LCFI1:
 101               		.cfi_def_cfa_offset 4
 102               		.cfi_offset 17, -3
 103 0042 CF93      		push r28
 104               	.LCFI2:
 105               		.cfi_def_cfa_offset 5
 106               		.cfi_offset 28, -4
 107               	/* prologue: function */
 108               	/* frame size = 0 */
 109               	/* stack size = 3 */
 110               	.L__stack_usage = 3
 111 0044 8C01      		movw r16,r24
 112               	.LVL2:
  48:USART.c       ****   uint8_t i = 0;
 113               		.loc 1 48 0
 114 0046 C0E0      		ldi r28,0
 115               	.LVL3:
 116               	.L11:
  49:USART.c       ****   while (myString[i]) {
 117               		.loc 1 49 0
 118 0048 F801      		movw r30,r16
 119 004a EC0F      		add r30,r28
 120 004c F11D      		adc r31,__zero_reg__
 121 004e 8081      		ld r24,Z
 122 0050 8823      		tst r24
 123 0052 01F0      		breq .L13
  50:USART.c       ****     transmitByte(myString[i]);
 124               		.loc 1 50 0
 125 0054 0E94 0000 		call transmitByte
 126               	.LVL4:
  51:USART.c       ****     i++;
 127               		.loc 1 51 0
 128 0058 CF5F      		subi r28,lo8(-(1))
 129               	.LVL5:
 130 005a 00C0      		rjmp .L11
 131               	.L13:
 132               	/* epilogue start */
  52:USART.c       ****   }
  53:USART.c       **** }
 133               		.loc 1 53 0
 134 005c CF91      		pop r28
 135               	.LVL6:
 136 005e 1F91      		pop r17
 137 0060 0F91      		pop r16
 138               	.LVL7:
 139 0062 0895      		ret
 140               		.cfi_endproc
 141               	.LFE3:
 143               	.global	readString
 145               	readString:
 146               	.LFB4:
  54:USART.c       **** 
  55:USART.c       **** void readString(char myString[], uint8_t maxLength) {
 147               		.loc 1 55 0
 148               		.cfi_startproc
 149               	.LVL8:
 150 0064 CF92      		push r12
 151               	.LCFI3:
 152               		.cfi_def_cfa_offset 3
 153               		.cfi_offset 12, -2
 154 0066 DF92      		push r13
 155               	.LCFI4:
 156               		.cfi_def_cfa_offset 4
 157               		.cfi_offset 13, -3
 158 0068 EF92      		push r14
 159               	.LCFI5:
 160               		.cfi_def_cfa_offset 5
 161               		.cfi_offset 14, -4
 162 006a FF92      		push r15
 163               	.LCFI6:
 164               		.cfi_def_cfa_offset 6
 165               		.cfi_offset 15, -5
 166 006c 0F93      		push r16
 167               	.LCFI7:
 168               		.cfi_def_cfa_offset 7
 169               		.cfi_offset 16, -6
 170 006e 1F93      		push r17
 171               	.LCFI8:
 172               		.cfi_def_cfa_offset 8
 173               		.cfi_offset 17, -7
 174 0070 CF93      		push r28
 175               	.LCFI9:
 176               		.cfi_def_cfa_offset 9
 177               		.cfi_offset 28, -8
 178 0072 DF93      		push r29
 179               	.LCFI10:
 180               		.cfi_def_cfa_offset 10
 181               		.cfi_offset 29, -9
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 8 */
 185               	.L__stack_usage = 8
 186 0074 6C01      		movw r12,r24
 187               	.LVL9:
  56:USART.c       ****   char response;
  57:USART.c       ****   uint8_t i;
  58:USART.c       ****   i = 0;
 188               		.loc 1 58 0
 189 0076 F12C      		mov r15,__zero_reg__
  59:USART.c       ****   while (i < (maxLength - 1)) {                   /* prevent over-runs */
 190               		.loc 1 59 0
 191 0078 062F      		mov r16,r22
 192 007a 10E0      		ldi r17,0
 193 007c 0150      		subi r16,1
 194 007e 1109      		sbc r17,__zero_reg__
 195               	.LVL10:
 196               	.L15:
 197 0080 CF2D      		mov r28,r15
 198 0082 D0E0      		ldi r29,0
 199 0084 C017      		cp r28,r16
 200 0086 D107      		cpc r29,r17
 201 0088 04F4      		brge .L18
  60:USART.c       ****     response = receiveByte();
 202               		.loc 1 60 0
 203 008a 0E94 0000 		call receiveByte
 204               	.LVL11:
 205 008e E82E      		mov r14,r24
 206               	.LVL12:
  61:USART.c       ****     transmitByte(response);                                    /* echo */
 207               		.loc 1 61 0
 208 0090 0E94 0000 		call transmitByte
 209               	.LVL13:
  62:USART.c       ****     if (response == '\r') {                     /* enter marks the end */
 210               		.loc 1 62 0
 211 0094 8DE0      		ldi r24,lo8(13)
 212 0096 E812      		cpse r14,r24
 213 0098 00C0      		rjmp .L16
 214               	.LVL14:
 215               	.L18:
  63:USART.c       ****       break;
  64:USART.c       ****     }
  65:USART.c       ****     else {
  66:USART.c       ****       myString[i] = response;                       /* add in a letter */
  67:USART.c       ****       i++;
  68:USART.c       ****     }
  69:USART.c       ****   }
  70:USART.c       ****   myString[i] = 0;                          /* terminal NULL character */
 216               		.loc 1 70 0
 217 009a CC0D      		add r28,r12
 218 009c DD1D      		adc r29,r13
 219 009e 1882      		st Y,__zero_reg__
 220               	/* epilogue start */
  71:USART.c       **** }
 221               		.loc 1 71 0
 222 00a0 DF91      		pop r29
 223 00a2 CF91      		pop r28
 224 00a4 1F91      		pop r17
 225 00a6 0F91      		pop r16
 226 00a8 FF90      		pop r15
 227               	.LVL15:
 228 00aa EF90      		pop r14
 229 00ac DF90      		pop r13
 230 00ae CF90      		pop r12
 231               	.LVL16:
 232 00b0 0895      		ret
 233               	.LVL17:
 234               	.L16:
  66:USART.c       ****       i++;
 235               		.loc 1 66 0
 236 00b2 CC0D      		add r28,r12
 237 00b4 DD1D      		adc r29,r13
 238 00b6 E882      		st Y,r14
  67:USART.c       ****     }
 239               		.loc 1 67 0
 240 00b8 F394      		inc r15
 241               	.LVL18:
 242 00ba 00C0      		rjmp .L15
 243               		.cfi_endproc
 244               	.LFE4:
 246               	.global	printByte
 248               	printByte:
 249               	.LFB5:
  72:USART.c       **** 
  73:USART.c       **** void printByte(uint8_t byte) {
 250               		.loc 1 73 0
 251               		.cfi_startproc
 252               	.LVL19:
 253 00bc CF93      		push r28
 254               	.LCFI11:
 255               		.cfi_def_cfa_offset 3
 256               		.cfi_offset 28, -2
 257               	/* prologue: function */
 258               	/* frame size = 0 */
 259               	/* stack size = 1 */
 260               	.L__stack_usage = 1
 261 00be C82F      		mov r28,r24
  74:USART.c       ****               /* Converts a byte to a string of decimal text, sends it */
  75:USART.c       ****   transmitByte('0' + (byte / 100));                        /* Hundreds */
 262               		.loc 1 75 0
 263 00c0 64E6      		ldi r22,lo8(100)
 264 00c2 0E94 0000 		call __udivmodqi4
 265               	.LVL20:
 266 00c6 805D      		subi r24,lo8(-(48))
 267 00c8 0E94 0000 		call transmitByte
 268               	.LVL21:
  76:USART.c       ****   transmitByte('0' + ((byte / 10) % 10));                      /* Tens */
 269               		.loc 1 76 0
 270 00cc 2AE0      		ldi r18,lo8(10)
 271 00ce 8C2F      		mov r24,r28
 272 00d0 622F      		mov r22,r18
 273 00d2 0E94 0000 		call __udivmodqi4
 274 00d6 C92F      		mov r28,r25
 275               	.LVL22:
 276 00d8 0E94 0000 		call __udivmodqi4
 277 00dc 80E3      		ldi r24,lo8(48)
 278 00de 890F      		add r24,r25
 279 00e0 0E94 0000 		call transmitByte
 280               	.LVL23:
  77:USART.c       ****   transmitByte('0' + (byte % 10));                             /* Ones */
 281               		.loc 1 77 0
 282 00e4 80E3      		ldi r24,lo8(48)
 283 00e6 8C0F      		add r24,r28
 284               	/* epilogue start */
  78:USART.c       **** }
 285               		.loc 1 78 0
 286 00e8 CF91      		pop r28
  77:USART.c       ****   transmitByte('0' + (byte % 10));                             /* Ones */
 287               		.loc 1 77 0
 288 00ea 0C94 0000 		jmp transmitByte
 289               	.LVL24:
 290               		.cfi_endproc
 291               	.LFE5:
 293               	.global	printWord
 295               	printWord:
 296               	.LFB6:
  79:USART.c       **** 
  80:USART.c       **** void printWord(uint16_t word) {
 297               		.loc 1 80 0
 298               		.cfi_startproc
 299               	.LVL25:
 300 00ee 0F93      		push r16
 301               	.LCFI12:
 302               		.cfi_def_cfa_offset 3
 303               		.cfi_offset 16, -2
 304 00f0 1F93      		push r17
 305               	.LCFI13:
 306               		.cfi_def_cfa_offset 4
 307               		.cfi_offset 17, -3
 308 00f2 CF93      		push r28
 309               	.LCFI14:
 310               		.cfi_def_cfa_offset 5
 311               		.cfi_offset 28, -4
 312 00f4 DF93      		push r29
 313               	.LCFI15:
 314               		.cfi_def_cfa_offset 6
 315               		.cfi_offset 29, -5
 316               	/* prologue: function */
 317               	/* frame size = 0 */
 318               	/* stack size = 4 */
 319               	.L__stack_usage = 4
 320 00f6 8C01      		movw r16,r24
  81:USART.c       ****   transmitByte('0' + (word / 10000));                 /* Ten-thousands */
 321               		.loc 1 81 0
 322 00f8 60E1      		ldi r22,lo8(16)
 323 00fa 77E2      		ldi r23,lo8(39)
 324 00fc 0E94 0000 		call __udivmodhi4
 325               	.LVL26:
 326 0100 80E3      		ldi r24,lo8(48)
 327 0102 860F      		add r24,r22
 328 0104 0E94 0000 		call transmitByte
 329               	.LVL27:
  82:USART.c       ****   transmitByte('0' + ((word / 1000) % 10));               /* Thousands */
 330               		.loc 1 82 0
 331 0108 C801      		movw r24,r16
 332 010a 68EE      		ldi r22,lo8(-24)
 333 010c 73E0      		ldi r23,lo8(3)
 334 010e 0E94 0000 		call __udivmodhi4
 335 0112 CB01      		movw r24,r22
 336 0114 CAE0      		ldi r28,lo8(10)
 337 0116 D0E0      		ldi r29,0
 338 0118 BE01      		movw r22,r28
 339 011a 0E94 0000 		call __udivmodhi4
 340 011e 805D      		subi r24,lo8(-(48))
 341 0120 0E94 0000 		call transmitByte
 342               	.LVL28:
  83:USART.c       ****   transmitByte('0' + ((word / 100) % 10));                 /* Hundreds */
 343               		.loc 1 83 0
 344 0124 C801      		movw r24,r16
 345 0126 64E6      		ldi r22,lo8(100)
 346 0128 70E0      		ldi r23,0
 347 012a 0E94 0000 		call __udivmodhi4
 348 012e CB01      		movw r24,r22
 349 0130 BE01      		movw r22,r28
 350 0132 0E94 0000 		call __udivmodhi4
 351 0136 805D      		subi r24,lo8(-(48))
 352 0138 0E94 0000 		call transmitByte
 353               	.LVL29:
  84:USART.c       ****   transmitByte('0' + ((word / 10) % 10));                      /* Tens */
 354               		.loc 1 84 0
 355 013c C801      		movw r24,r16
 356 013e BE01      		movw r22,r28
 357 0140 0E94 0000 		call __udivmodhi4
 358 0144 182F      		mov r17,r24
 359 0146 CB01      		movw r24,r22
 360 0148 BE01      		movw r22,r28
 361 014a 0E94 0000 		call __udivmodhi4
 362 014e 805D      		subi r24,lo8(-(48))
 363 0150 0E94 0000 		call transmitByte
 364               	.LVL30:
  85:USART.c       ****   transmitByte('0' + (word % 10));                             /* Ones */
 365               		.loc 1 85 0
 366 0154 80E3      		ldi r24,lo8(48)
 367 0156 810F      		add r24,r17
 368               	/* epilogue start */
  86:USART.c       **** }
 369               		.loc 1 86 0
 370 0158 DF91      		pop r29
 371 015a CF91      		pop r28
 372 015c 1F91      		pop r17
 373 015e 0F91      		pop r16
 374               	.LVL31:
  85:USART.c       ****   transmitByte('0' + (word % 10));                             /* Ones */
 375               		.loc 1 85 0
 376 0160 0C94 0000 		jmp transmitByte
 377               	.LVL32:
 378               		.cfi_endproc
 379               	.LFE6:
 381               	.global	printBinaryByte
 383               	printBinaryByte:
 384               	.LFB7:
  87:USART.c       **** 
  88:USART.c       **** void printBinaryByte(uint8_t byte) {
 385               		.loc 1 88 0
 386               		.cfi_startproc
 387               	.LVL33:
 388 0164 1F93      		push r17
 389               	.LCFI16:
 390               		.cfi_def_cfa_offset 3
 391               		.cfi_offset 17, -2
 392 0166 CF93      		push r28
 393               	.LCFI17:
 394               		.cfi_def_cfa_offset 4
 395               		.cfi_offset 28, -3
 396 0168 DF93      		push r29
 397               	.LCFI18:
 398               		.cfi_def_cfa_offset 5
 399               		.cfi_offset 29, -4
 400 016a 1F92      		push __zero_reg__
 401               	.LCFI19:
 402               		.cfi_def_cfa_offset 6
 403 016c CDB7      		in r28,__SP_L__
 404 016e DEB7      		in r29,__SP_H__
 405               	.LCFI20:
 406               		.cfi_def_cfa_register 28
 407               	/* prologue: function */
 408               	/* frame size = 1 */
 409               	/* stack size = 4 */
 410               	.L__stack_usage = 4
 411 0170 8983      		std Y+1,r24
 412               	.LVL34:
  89:USART.c       ****                        /* Prints out a byte as a series of 1's and 0's */
  90:USART.c       ****   uint8_t bit;
  91:USART.c       ****   for (bit = 7; bit < 255; bit--) {
 413               		.loc 1 91 0
 414 0172 17E0      		ldi r17,lo8(7)
 415               	.LVL35:
 416               	.L25:
  92:USART.c       ****     if (bit_is_set(byte, bit))
 417               		.loc 1 92 0
 418 0174 8981      		ldd r24,Y+1
 419               		.loc 1 92 0
 420 0176 90E0      		ldi r25,0
 421 0178 012E      		mov r0,r17
 422 017a 00C0      		rjmp 2f
 423               		1:
 424 017c 9595      		asr r25
 425 017e 8795      		ror r24
 426               		2:
 427 0180 0A94      		dec r0
 428 0182 02F4      		brpl 1b
 429 0184 80FF      		sbrs r24,0
 430 0186 00C0      		rjmp .L23
  93:USART.c       ****       transmitByte('1');
 431               		.loc 1 93 0
 432 0188 81E3      		ldi r24,lo8(49)
 433 018a 00C0      		rjmp .L27
 434               	.L23:
  94:USART.c       ****     else
  95:USART.c       ****       transmitByte('0');
 435               		.loc 1 95 0
 436 018c 80E3      		ldi r24,lo8(48)
 437               	.L27:
 438 018e 0E94 0000 		call transmitByte
 439               	.LVL36:
  91:USART.c       ****     if (bit_is_set(byte, bit))
 440               		.loc 1 91 0
 441               	.LVL37:
 442 0192 1150      		subi r17,1
 443 0194 00F4      		brcc .L25
 444               	/* epilogue start */
  96:USART.c       ****   }
  97:USART.c       **** }
 445               		.loc 1 97 0
 446 0196 0F90      		pop __tmp_reg__
 447 0198 DF91      		pop r29
 448 019a CF91      		pop r28
 449               	.LVL38:
 450 019c 1F91      		pop r17
 451               	.LVL39:
 452 019e 0895      		ret
 453               		.cfi_endproc
 454               	.LFE7:
 456               	.global	nibbleToHexCharacter
 458               	nibbleToHexCharacter:
 459               	.LFB8:
  98:USART.c       **** 
  99:USART.c       **** char nibbleToHexCharacter(uint8_t nibble) {
 460               		.loc 1 99 0
 461               		.cfi_startproc
 462               	.LVL40:
 463               	/* prologue: function */
 464               	/* frame size = 0 */
 465               	/* stack size = 0 */
 466               	.L__stack_usage = 0
 100:USART.c       ****                                    /* Converts 4 bits into hexadecimal */
 101:USART.c       ****   if (nibble < 10) {
 467               		.loc 1 101 0
 468 01a0 8A30      		cpi r24,lo8(10)
 469 01a2 00F4      		brsh .L29
 102:USART.c       ****     return ('0' + nibble);
 470               		.loc 1 102 0
 471 01a4 805D      		subi r24,lo8(-(48))
 472               	.LVL41:
 473 01a6 0895      		ret
 474               	.LVL42:
 475               	.L29:
 103:USART.c       ****   }
 104:USART.c       ****   else {
 105:USART.c       ****     return ('A' + nibble - 10);
 476               		.loc 1 105 0
 477 01a8 895C      		subi r24,lo8(-(55))
 478               	.LVL43:
 106:USART.c       ****   }
 107:USART.c       **** }
 479               		.loc 1 107 0
 480 01aa 0895      		ret
 481               		.cfi_endproc
 482               	.LFE8:
 484               	.global	printHexByte
 486               	printHexByte:
 487               	.LFB9:
 108:USART.c       **** 
 109:USART.c       **** void printHexByte(uint8_t byte) {
 488               		.loc 1 109 0
 489               		.cfi_startproc
 490               	.LVL44:
 491 01ac CF93      		push r28
 492               	.LCFI21:
 493               		.cfi_def_cfa_offset 3
 494               		.cfi_offset 28, -2
 495               	/* prologue: function */
 496               	/* frame size = 0 */
 497               	/* stack size = 1 */
 498               	.L__stack_usage = 1
 499 01ae C82F      		mov r28,r24
 500               	.LVL45:
 110:USART.c       ****                         /* Prints a byte as its hexadecimal equivalent */
 111:USART.c       ****   uint8_t nibble;
 112:USART.c       ****   nibble = (byte & 0b11110000) >> 4;
 113:USART.c       ****   transmitByte(nibbleToHexCharacter(nibble));
 501               		.loc 1 113 0
 502 01b0 8295      		swap r24
 503               	.LVL46:
 504 01b2 8F70      		andi r24,lo8(15)
 505 01b4 0E94 0000 		call nibbleToHexCharacter
 506               	.LVL47:
 507 01b8 0E94 0000 		call transmitByte
 508               	.LVL48:
 114:USART.c       ****   nibble = byte & 0b00001111;
 115:USART.c       ****   transmitByte(nibbleToHexCharacter(nibble));
 509               		.loc 1 115 0
 510 01bc 8C2F      		mov r24,r28
 511 01be 8F70      		andi r24,lo8(15)
 512               	.LVL49:
 513 01c0 0E94 0000 		call nibbleToHexCharacter
 514               	.LVL50:
 515               	/* epilogue start */
 116:USART.c       **** }
 516               		.loc 1 116 0
 517 01c4 CF91      		pop r28
 518               	.LVL51:
 115:USART.c       **** }
 519               		.loc 1 115 0
 520 01c6 0C94 0000 		jmp transmitByte
 521               	.LVL52:
 522               		.cfi_endproc
 523               	.LFE9:
 525               	.global	getNumber
 527               	getNumber:
 528               	.LFB10:
 117:USART.c       **** 
 118:USART.c       **** uint8_t getNumber(void) {
 529               		.loc 1 118 0
 530               		.cfi_startproc
 531 01ca 0F93      		push r16
 532               	.LCFI22:
 533               		.cfi_def_cfa_offset 3
 534               		.cfi_offset 16, -2
 535 01cc 1F93      		push r17
 536               	.LCFI23:
 537               		.cfi_def_cfa_offset 4
 538               		.cfi_offset 17, -3
 539 01ce CF93      		push r28
 540               	.LCFI24:
 541               		.cfi_def_cfa_offset 5
 542               		.cfi_offset 28, -4
 543 01d0 DF93      		push r29
 544               	.LCFI25:
 545               		.cfi_def_cfa_offset 6
 546               		.cfi_offset 29, -5
 547               	/* prologue: function */
 548               	/* frame size = 0 */
 549               	/* stack size = 4 */
 550               	.L__stack_usage = 4
 551               	.LVL53:
 119:USART.c       ****   // Gets a numerical 0-255 from the serial port.
 120:USART.c       ****   // Converts from string to number.
 121:USART.c       ****   char hundreds = '0';
 122:USART.c       ****   char tens = '0';
 123:USART.c       ****   char ones = '0';
 124:USART.c       ****   char thisChar = '0';
 552               		.loc 1 124 0
 553 01d2 D0E3      		ldi r29,lo8(48)
 123:USART.c       ****   char thisChar = '0';
 554               		.loc 1 123 0
 555 01d4 C0E3      		ldi r28,lo8(48)
 122:USART.c       ****   char ones = '0';
 556               		.loc 1 122 0
 557 01d6 10E3      		ldi r17,lo8(48)
 558               	.LVL54:
 559               	.L33:
 125:USART.c       ****   do {                                                   /* shift over */
 126:USART.c       ****     hundreds = tens;
 127:USART.c       ****     tens = ones;
 128:USART.c       ****     ones = thisChar;
 129:USART.c       ****     thisChar = receiveByte();                   /* get a new character */
 560               		.loc 1 129 0 discriminator 1
 561 01d8 0E94 0000 		call receiveByte
 562               	.LVL55:
 563 01dc 082F      		mov r16,r24
 564               	.LVL56:
 130:USART.c       ****     transmitByte(thisChar);                                    /* echo */
 565               		.loc 1 130 0 discriminator 1
 566 01de 0E94 0000 		call transmitByte
 567               	.LVL57:
 131:USART.c       ****   } while (thisChar != '\r');                     /* until type return */
 568               		.loc 1 131 0 discriminator 1
 569 01e2 0D30      		cpi r16,lo8(13)
 570 01e4 01F0      		breq .L35
 571 01e6 1C2F      		mov r17,r28
 572               	.LVL58:
 573 01e8 CD2F      		mov r28,r29
 574               	.LVL59:
 575 01ea D02F      		mov r29,r16
 576               	.LVL60:
 577 01ec 00C0      		rjmp .L33
 578               	.LVL61:
 579               	.L35:
 132:USART.c       ****   return (100 * (hundreds - '0') + 10 * (tens - '0') + ones - '0');
 580               		.loc 1 132 0
 581 01ee 1053      		subi r17,lo8(-(-48))
 582               	.LVL62:
 583 01f0 D053      		subi r29,lo8(-(-48))
 584               	.LVL63:
 585 01f2 84E6      		ldi r24,lo8(100)
 586 01f4 189F      		mul r17,r24
 587 01f6 D00D      		add r29,r0
 588 01f8 1124      		clr __zero_reg__
 589               	.LVL64:
 590 01fa CC0F      		lsl r28
 591               	.LVL65:
 592 01fc C056      		subi r28,lo8(-(-96))
 593 01fe 8C2F      		mov r24,r28
 594 0200 880F      		lsl r24
 595 0202 880F      		lsl r24
 596 0204 8C0F      		add r24,r28
 133:USART.c       **** }
 597               		.loc 1 133 0
 598 0206 8D0F      		add r24,r29
 599               	/* epilogue start */
 600 0208 DF91      		pop r29
 601 020a CF91      		pop r28
 602 020c 1F91      		pop r17
 603               	.LVL66:
 604 020e 0F91      		pop r16
 605               	.LVL67:
 606 0210 0895      		ret
 607               		.cfi_endproc
 608               	.LFE10:
 610               	.Letext0:
 611               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 USART.c
             USART.s:2      *ABS*:000000000000003e __SP_H__
             USART.s:3      *ABS*:000000000000003d __SP_L__
             USART.s:4      *ABS*:000000000000003f __SREG__
             USART.s:5      *ABS*:0000000000000000 __tmp_reg__
             USART.s:6      *ABS*:0000000000000001 __zero_reg__
             USART.s:12     .text:0000000000000000 initUSART
             USART.s:44     .text:0000000000000022 transmitByte
             USART.s:67     .text:0000000000000030 receiveByte
             USART.s:90     .text:000000000000003e printString
             USART.s:145    .text:0000000000000064 readString
             USART.s:248    .text:00000000000000bc printByte
             USART.s:295    .text:00000000000000ee printWord
             USART.s:383    .text:0000000000000164 printBinaryByte
             USART.s:458    .text:00000000000001a0 nibbleToHexCharacter
             USART.s:486    .text:00000000000001ac printHexByte
             USART.s:527    .text:00000000000001ca getNumber

UNDEFINED SYMBOLS
__udivmodqi4
__udivmodhi4
